use crate::ast::Expr;
use crate::ast::Op;
use crate::ast::IOpType;
use crate::value::Type;
use crate::vm::Evaluateur;

use crate::expr::assign;
use crate::expr::call;
use crate::expr::callstruct; 
use crate::expr::enum_;
use crate::expr::enumcall;
use crate::expr::fundef;
use crate::expr::literal;
use crate::expr::ifthen;
use crate::expr::ifthenelse;
use crate::expr::loop_for;
use crate::expr::loop_while;
use crate::expr::binop;
use crate::expr::iop;
use crate::expr::setvar;
use crate::expr::list;
use crate::expr::getattr;
use crate::expr::getfunc;
use crate::expr::impl_;
use crate::expr::range;
use crate::expr::match_;
use crate::expr::block;
use crate::expr::ident;
use crate::expr::index;
use crate::expr::to;
use crate::expr::structdef;
use crate::expr::typeof_;
use crate::expr::type_;
use crate::expr::module;
use crate::expr::getmodattr;
use crate::expr::getmodfunc;

use std::fs;

grammar;
pub Exprs : Expr = MultiLine<Expr> => Expr::Block( block::Block {
    body: <>
});
Identifier : Expr = <i:r"[a-zA-Z_][a-zA-Z0-9_]*"> => Expr::Ident(
    ident::Ident(i.to_string())
);
Block: Expr = "{" <e:Exprs> "}" => e;
Num : Expr = <n:r"[0-9]+"> => Expr::Literal(
    literal::Literal(
        literal::LiteralType::Number(
            n.parse().unwrap()
        )
    )
);
Str : Expr = <s:r#"'(\\.|[^'])*'"#> => Expr::Literal(
    literal::Literal(
        literal::LiteralType::String(
            s[1..s.len()-1].to_string()
        )
    )
);
IfExpr : Expr = "if" <e:Expr> "{" <e1:Exprs>  "}" => Expr::IfThen(
    ifthen::IfThen {
        cond: Box::new(e),
        then: Box::new(e1)
    }
);
IfElseExpr : Expr = <e1:IfExpr> "else" <e2:Block>  => {
    match e1 {
        Expr::IfThen(ifthen::IfThen{cond, then}) => Expr::IfThenElse (
            ifthenelse::IfThenElse {
                cond,
                then, 
                else_: Box::new(e2)
            }
        ),
        _ => panic!("Invalid if-else expression")
    }
};

ForExpr : Expr = "for" <e1:Expr> "in" <e2:Expr> "{" <e3:Exprs> "}" => Expr::For (
    loop_for::For {
        name: match e1 {
            Expr::Ident(ident::Ident(i)) => i,
            _ => panic!("Invalid for expression")
        },
        iter: Box::new(e2),
        body: Box::new(e3)
    }
);

WhileExpr : Expr = "while" <e1:Expr> "{" <e2:Exprs> "}" => Expr::While(
    loop_while::While {
        cond: Box::new(e1),
        body: Box::new(e2)
    }
);


LetExpr : Expr = "let" <e1:Identifier> <e2:(":" Expr)?> "=" <e3:Expr>  => Expr::Assign(
    assign::Assign{
        name: match e1 {
            Expr::Ident(ident::Ident(i)) => i,
            _ => panic!("Invalid let expression")
        }, 
        value: Box::new(e3),
        mutable: true,
        type_: match e2 {
            Some(e) => Some(Box::new(e.1)),
            None => None
        }
    }
);

Op: Expr = {
    <e1:Value> "+" <e2:Fact> => Expr::BinOp(
        binop::BinOp {
            left: Box::new(e1), 
            op: Op::Add, 
            right: Box::new(e2)
        }
    ),
    <e1:Value> "-" <e2:Fact> => Expr::BinOp (
        binop::BinOp {
            left: Box::new(e1), 
            op: Op::Sub, 
            right: Box::new(e2)
        }
    ),
    Fact
};


Fact: Expr = {
    <e1:Fact> "*" <e2:Value> => Expr::BinOp (
        binop::BinOp {
            left: Box::new(e1), 
            op: Op::Mul, 
            right: Box::new(e2)
        }
    ),
    <e1:Fact> "/" <e2:Value> => Expr::BinOp (
        binop::BinOp{
            left: Box::new(e1), 
            op: Op::Div, 
            right: Box::new(e2)
        }
    ),
    Value

};

CmpOp: Expr = {
    <e1:Value> "==" <e2:Value> => Expr::BinOp (
        binop::BinOp{
            left: Box::new(e1), 
            op: Op::Eq, 
            right: Box::new(e2)
        }
    ),
    <e1:Value> "!=" <e2:Value> => Expr::BinOp(
        binop::BinOp {
            left: Box::new(e1), 
            op: Op::Neq, 
            right: Box::new(e2)
        }
    ),
    <e1:Value> "<" <e2:Value> => Expr::BinOp(
        binop::BinOp{
            left: Box::new(e1), 
            op: Op::Ge, 
            right: Box::new(e2)
        }
    ),
    <e1:Value> "<=" <e2:Value> => Expr::BinOp(
        binop::BinOp{
            left: Box::new(e1), 
            op: Op::Le, 
            right: Box::new(e2)
        }
    ),
    <e1:Value> ">" <e2:Value> => Expr::BinOp(
        binop::BinOp{
            left: Box::new(e1), 
            op: Op::Gt, 
            right: Box::new(e2)
        }
    ),
    <e1:Value> ">=" <e2:Value> => Expr::BinOp(
        binop::BinOp{
            left: Box::new(e1), 
            op: Op::Lt, 
            right: Box::new(e2)
        }
    )
};

IOp : Expr = {
    <e1:Identifier> "+=" <e2:Expr> => Expr::IOp(iop::IOp{name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid let expression")
    }, op: IOpType::IAdd, value: Box::new(e2)}),

    <e1:Identifier> "-=" <e2:Expr> => Expr::IOp(iop::IOp{name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid let expression")
    }, op: IOpType::ISub, value: Box::new(e2)}),

    <e1:Identifier> "*=" <e2:Expr> => Expr::IOp(iop::IOp{name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid let expression")
    }, op: IOpType::IMul, value: Box::new(e2)}),

    <e1:Identifier> "/=" <e2:Expr> => Expr::IOp(iop::IOp{name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid let expression")
    }, op: IOpType::IDiv, value: Box::new(e2)})
};

SetVar: Expr = <e1:Identifier> ":=" <e2:Expr> => Expr::SetVar(
    setvar::SetVar {
        name: match e1 {
            Expr::Ident(
                ident::Ident(ident)
             ) => ident,
            _ => panic!("Invalid set-var expression")
        }, 
        value: Box::new(e2)
    }
);

List: Expr = {
    "[" <s:Expr *> <e:("," Expr)*> "]" => {
        let i = s.into_iter();
        let n = e.into_iter().map(|x| x.1);
        Expr::List (list::List {
            elems: i.chain(n).collect::<Vec<Expr>>()
        })
    }
};

ArgDef: Vec<(ident::Ident, Expr)> = {
    "(" <s:(Identifier ":" Expr)*> <e:("," Identifier ":" Expr)*> ")"  => {
        let i = s.into_iter().map(|x| (match x.0 {
            Expr::Ident(ident) => ident,
            _ => panic!("Invalid argument definition")
        }, x.2));
        let n = e.into_iter().map(|x| (match x.1 {
            Expr::Ident(ident) => ident,
            _ => panic!("Invalid argument definition")
        }, x.3));
        i.chain(n).collect::<Vec<(ident::Ident, Expr)>>()
    }
}; 

ArgCall: Vec<Expr> = {
    "(" <s:Expr?> <e:("," Expr)*> ")"  => {
        let i = match s {
            Some(x) => vec![x],
            None => vec![]
        }.into_iter();
        let n = e.into_iter().map(|x| x.1);
        n.chain(i).collect::<Vec<Expr>>()
    }
};

FunDef : Expr = "def" <e1:Identifier>  <e2:ArgDef>  "{" <e3:Exprs> "}" => {
    match e1 {
        Expr::Ident(ident::Ident(ident)) => Expr::FunDef(
            fundef::FunDef{
                name: ident, 
                args: e2, 
                body: Box::new(e3) 
            }
        ),
        _ => panic!("Invalid function definition")
    }
}; 

True : Expr = "true" => Expr::Literal(
    literal::Literal(literal::LiteralType::Bool(true))
);

False : Expr = "false" => Expr::Literal(
    literal::Literal(literal::LiteralType::Bool(false))
);

Call : Expr =  <e1:Identifier> <e2:ArgCall>  => Expr::Call( call::Call {
    name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid function call")

    },
    args: e2
});

FieldDef : Vec<ident::Ident> = {
    <s:Identifier> <e:(";" Identifier)*>  => {
        let mut i = vec![match s {
            Expr::Ident(id) => id,
            _ => panic!("Invalid field definition")
        }];
        let n = &mut e.into_iter().map(|x| match x.1 {
            Expr::Ident(id) => id,
            _ => panic!("Invalid field definition")
        }).collect::<Vec<ident::Ident>>();
        i.append(n);
        i
    }
}; 

EnumFieldDef : Vec<String> = {
    <s:Identifier> <e:(";" Identifier)*>  => {
        let mut i = vec![match s {
            Expr::Ident(ident::Ident(ident)) => ident,
            _ => panic!("Invalid enum field definition")
        }];
        let n = &mut e.into_iter().map(|x| match x.1 {
            Expr::Ident(ident::Ident(ident)) => ident,
            _ => panic!("Invalid enum field definition")
        }).collect::<Vec<String>>();
        i.append(n);
        i
    }
};


FieldCall : Vec<(ident::Ident, Expr)> = {
    "{" <s:(Identifier "=>" Expr)*> <e:(";" (Identifier "=>" Expr))*> "}"   => {

        let i = s.into_iter().map(|x| (match x.0 {
            Expr::Ident(ident) => ident,
            _ => panic!("Invalid field call")
        }, x.2));
        let n = e.into_iter().map(|x| (match x.1.0 {
            Expr::Ident(ident) => ident,
            _ => panic!("Invalid field call")
        }, x.1.2));
        i.chain(n).collect::<Vec<(ident::Ident, Expr)>>()
    }
};

Struct : Expr = "struct" <e1:Identifier> "{" <e2:FieldDef> "}" => Expr::StructDef (structdef::StructDef{name: match e1 {
    Expr::Ident(ident::Ident(ident)) => ident,
    _ => panic!("Invalid struct")
}, fields: e2});

CallStruct : Expr = "@" <e1:Identifier>  <e2:FieldCall>   => Expr::CallStruct ( callstruct::CallStruct {
    name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid struct call")
    }, 
    args: e2
});

GetAttr : Expr = <e1:Identifier> "->" <e2:Identifier> => Expr::GetAttr(getattr::GetAttr {name: match e1 {
    Expr::Ident(ident::Ident(ident)) => ident,
    _ => panic!("Invalid get attribute")
}, attr: match e2 {
    Expr::Ident(ident::Ident(ident)) => ident,
    _ => panic!("Invalid get attribute")
}});

Impl : Expr = "impl" <e1:Identifier> "def" <e2:Identifier> <e3:ArgDef> <e4:Block> => {
    Expr::Impl (impl_::Impl{
        name_struct: match e1 {
            Expr::Ident(ident::Ident(ident)) => ident,
            _ => panic!("Invalid impl")
        }, name_method: match e2 {
            Expr::Ident(ident::Ident(ident)) => ident,
            _ => panic!("Invalid impl")
        }, args: e3, body: Box::new(e4)
    })
};

GetFunc : Expr = <e1:Identifier> "->"  <e2:Identifier> <e3:ArgCall> => Expr::GetFunc (getfunc::GetFunc{
    name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid get func")
    }, func: match e2 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid get func")
    }, args: e3
});

Range : Expr = <e1:Num> ":" <e2:Value> => Expr::Range(range::Range{start: Box::new(e1), end: Box::new(e2)});

Index : Expr = <e1:Identifier> "." <e2:Value> => Expr::Index(index::Index {name: match e1 {
    Expr::Ident(i) => i,
    _ => panic!("Invalid index")
}, index: Box::new(e2)});

MatchCase : Vec<(Expr, Expr)> = {
    <s:(Expr "=>" Expr)*> <e:("," (Expr "=>" Expr))*>   => {

        let i = s.into_iter().map(|x| (x.0, x.2));
        let n = e.into_iter().map(|x| (x.1.0, x.1.2));
        i.chain(n).collect::<Vec<(Expr, Expr)>>()
    }
};
StringType: Expr = "string" => Expr::TypeExpr(type_::TypeExpr(Type::String));
BoolType: Expr = "bool" => Expr::TypeExpr(type_::TypeExpr(Type::Bool));
IntType: Expr = "int" => Expr::TypeExpr(type_::TypeExpr(Type::Int));
TypeType: Expr = "type" <e1:Identifier> => Expr::TypeExpr(type_::TypeExpr(Type::Type(match e1 {
    Expr::Ident(ident::Ident(ident)) => ident,
    _ => panic!("Invalid type")
})));
Type : Expr = {StringType, BoolType, IntType, TypeOf,TypeType};

Match : Expr = "match" <e1:Expr> "{" <e2:MatchCase> "}" => Expr::Match(match_::Match{value: Box::new(e1), cases: e2});

Enum: Expr = "enum" <e1:Identifier> "{" <e2:EnumFieldDef> "}" => Expr::Enum (enum_::Enum{name: match e1 {
    Expr::Ident(ident::Ident(ident)) => ident,
    _ => panic!("Invalid enum")
}, 
fields: e2
});

EnumCall: Expr = "@" <e1:Identifier> "{" <e2:Identifier> "}" => {
    Expr::EnumCall(enumcall::EnumCall {
        name: match e1 {
            Expr::Ident(ident::Ident(ident)) => ident,
            _ => panic!("Invalid enum call")
        },
        field: match e2 {
            Expr::Ident(ident::Ident(ident)) => ident,
            _ => panic!("Invalid enum call")
        }
    }
)};

To: Expr = <e1:Value> "to" <e2:Type> => Expr::To(to::To{value: Box::new(e1), type_: Box::new(e2)}); 

Const: Expr = "const" <e1:Identifier> <e2:(":" Type)?> "=" <e3:Expr>  => Expr::Assign(assign::Assign{name: match e1 {
    Expr::Ident(ident::Ident(ident)) => ident,
    _ => panic!("Invalid let expression")
    }, value: Box::new(e3),
    mutable: true,
    type_: match e2 {
        Some(e) => Some(Box::new(e.1)),
        None => None
    }
});

TypeOf : Expr = "typeof" <e1:Expr> => Expr::Typeof(typeof_::Typeof{value: Box::new(e1)});

Module : Expr = "import" <e1:Str> => Expr::Module(module::Module{name: match e1 {
    Expr::Literal(literal::Literal(literal::LiteralType::String(s))) => s,
    _ => panic!("Invalid module")
}});

GetModAttr : Expr = <e1:Identifier> "::" <e2:Identifier> => Expr::GetModAttr(getmodattr::GetModAttr{
    mod_name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid get module attribute")
    },
    attr_name: match e2 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid get module attribute")
    }
});

GetModFunc : Expr = <e1:Identifier> "::" "@" <e2:Identifier> <e3:ArgCall> => Expr::GetModFunc(getmodfunc::GetModFunc{
    mod_name: match e1 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid get module function")
    },
    func_name: match e2 {
        Expr::Ident(ident::Ident(ident)) => ident,
        _ => panic!("Invalid get module function")
    },
    args: e3
});
 


Value = { 
    Num, 
    Str, 
    Identifier, 
    True, 
    False, 
    Call, 
    Index, 
    List, 
    Range,
    
};


Expr = {
    Block,
    IfExpr,
    IfElseExpr,
    ForExpr,
    WhileExpr,
    LetExpr,
    Struct,
    CallStruct,
    FunDef,
    Impl,
    GetFunc,
    SetVar,
    IOp,
    Match,
    Op,
    CmpOp,
    Enum,
    EnumCall,
    To,
    Const,
    Type,
    Module,
    GetModAttr,
    GetModFunc,
    GetAttr

};



MultiLine<T> : Vec<T> = {
    <v:(<T> ";") *>  => {
        v.into_iter().collect()
    }
};



