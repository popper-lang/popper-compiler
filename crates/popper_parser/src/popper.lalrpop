use std::str::FromStr;
use popper_ast::Expression;
use popper_ast::Statement;
use popper_ast::BinOp;
use popper_ast::BinOpKind;
use popper_ast::Span;
use popper_ast::Constant;
use popper_ast::Int;
use popper_ast::Block;
use popper_ast::While;
use popper_ast::ParenGroup;
use popper_ast::Ident;
use popper_ast::Bool;
use popper_ast::StringLiteral as AstString;
use popper_ast::Type;
use popper_ast::TypeKind;
use popper_ast::LetStmt;

grammar<'a>;

Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap(),
};

Str: String = {
    <s:r#""(\\.|[^"])*""#> => s.replace("\\\"", "\"").replace("\"", ""), // remove quotes

};


Chars: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();

OpTerm: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub,
}

OpFactor: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
}

BinOp<Lhs, Op, Rhs>: Expression = {
    <ll:@L> <l:Lhs> <op:Op> <r:Rhs> <lr:@R> => {
        Expression::BinOp(BinOp::new(Span::new(ll, lr), op, l,  r))
    }
}

Group<DelimS, T, DelimE>: (Span, T) = {
    <ll:@L> <ds:DelimS> <t:T> <de:DelimE> <lr:@R> => (Span::new(ll, lr), t)
}

BlockStmt: Statement = {
    <e:Group<"{", Statement*, "}">> => {
        Statement::Block(
            Block::new(
                e.0,
                e.1
            )
        )
    }

}

WhileStmt: (Expression, Statement) = {
    "while" <cond:Expr> <body:Statement>  => {
        (cond, body)
    }
}

While: Statement = {
    <t:Span<WhileStmt>> => {
        Statement::While(
            While::new(
                t.0,
                t.1.0,
                t.1.1
            )
        )
    }
}

GenericTypes: (Type, Vec<Type>) = {
    <t:Types> "<" <ts:Comma<Types>> ">" => {
        (t, ts)
    }
}

Types: Type = {
    <int:Span<"int">> => Type::new(int.0, TypeKind::Int, vec![]),
    <bool:Span<"bool">> => Type::new(bool.0, TypeKind::Bool, vec![]),
    <str:Span<"string">> => Type::new(str.0, TypeKind::String, vec![]),
    <unit:Span<"unit">> => Type::new(unit.0, TypeKind::Unit, vec![]),
    <generic:Span<GenericTypes>> => {
        Type::new(generic.0, generic.1.0.type_kind, generic.1.1)
    }


}

TypeDecl: (Ident, Type) = {
    <t:Ident> ":" <ty:Types> => {
        (
            t,
            ty
        )
    }
}

LetStmt: (Ident, Type, Expression) = {
    "let" <td:TypeDecl> "=" <e:Expr> => {
        (td.0, td.1, e)
    }
}

Let: Statement = {
    <t:Span<LetStmt>> ";" => {
        Statement::Let(
            LetStmt::new(
                t.0,
                t.1.0,
                t.1.1,
                true,
                t.1.2
            )
        )
    }
}

Expr: Expression = {
    BinOp<Expr, OpTerm, Factor>,
    Factor,
};

Factor: Expression = {
    BinOp<Factor, OpFactor, Term>,
    Term
};

ParenGroup: Expression = {
    <g:Group<"(", Expr, ")">> => {
        Expression::Group(
            ParenGroup::new(
                g.0,
                g.1
            )
        )
    }

};

Term: Expression = {
    Int,
    ParenGroup,
    ExprIdent,
    Bool,
    String
};


Ident: Ident = {
    <t:Span<Chars>> => {
        Ident::new(
            t.0,
            t.1.to_string()
        )
    }
}

ExprIdent: Expression = {
    <t:Ident> => Expression::Constant(
                    Constant::Ident(
                        t
                    )
                 )
}

Int: Expression = {
    <t:Span<Num>> => Expression::Constant(
                                Constant::Int(
                                    Int::new(
                                        t.0,
                                        t.1
                                    )
                                )
                            )
}

Bool: Expression = {
    Span<"true"> => Expression::Constant(Constant::Bool(Bool::new(<>.0, true))),
    Span<"false"> => Expression::Constant(Constant::Bool(Bool::new(<>.0, false)))
}

String: Expression = {
    <t:Span<Str>> => Expression::Constant(
                                Constant::StringLiteral(
                                    AstString::new(
                                        t.0,
                                        t.1
                                    )
                                )
                            )
}

Span<T>: (Span, T) = {
    <ll:@L> <t:T> <lr:@R> => (Span::new(ll, lr), t)
}

Comma<T>: Vec<T> = {
    <t:T> "," <ts:Comma<T>> => {
        let mut vec = vec![t];
        vec.extend(ts);
        vec
    },
    <t:T> => vec![t]
}

Statement: Statement = {
    BlockStmt,
    While,
    Let,
    <e:Expr> ";" => { Statement::Expression(e) }
}

pub File: Vec<Statement> = {
    <stmts:Statement*> => { stmts }
}