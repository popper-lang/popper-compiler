use std::str::FromStr;
use popper_ast::Expression;
use popper_ast::Statement;
use popper_ast::BinOp;
use popper_ast::BinOpKind;
use popper_ast::Span;
use popper_ast::Constant;
use popper_ast::Int;
use popper_ast::Block;
use popper_ast::While;
use popper_ast::Ident;
use popper_ast::Bool;
use popper_ast::StringLiteral as AstString;
use popper_ast::Type;
use popper_ast::TypeKind;
use popper_ast::LetStmt;
use popper_ast::If;
use popper_ast::IfElse;
use popper_ast::Argument;
use popper_ast::Arguments;
use popper_ast::Function;
use popper_ast::Call;
use popper_ast::Return;
use popper_ast::PathImport;
use popper_ast::ImportStmt;

grammar<'a>;

Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap(),
};

Str: String = {
    <s:r#""(\\.|[^"])*""#> => s.replace("\\\"", "\"").replace("\"", ""), // remove quotes

};


Chars: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();

OpTerm: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub,
}

OpFactor: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
}

ConditionalStatement<K>: (Expression, Statement) = {
    <keyword:K> <condition:Expr> <statement:Statement>   => (condition, statement)
}

BinOp<Lhs, Op, Rhs>: Expression = {
    <ll:@L> <l:Lhs> <op:Op> <r:Rhs> <lr:@R> => {
        Expression::BinOp(BinOp::new(Span::new(ll, lr), op, l,  r))
    }
}

Group<DelimS, T, DelimE>: (Span, T) = {
    <ll:@L> <ds:DelimS> <t:T> <de:DelimE> <lr:@R> => (Span::new(ll, lr), t)
}

Block: Vec<Statement> = {
    <e:Group<"{", Statement*, "}">> => e.1
}

BlockStmt: Statement = {
    <e:Group<"{", Statement*, "}">> => {
        Statement::Block(
            Block::new(
                e.0,
                e.1
            )
        )
    }

}



While: Statement = {
    <t:Span<ConditionalStatement<"while">>> => {
        Statement::While(
            While::new(
                t.0,
                t.1.0,
                t.1.1
            )
        )
    }
}

GenericTypes: (Type, Vec<Type>) = {
    <t:Types> "<" <ts:Comma<Types>> ">" => {
        (t, ts)
    }
}

Types: Type = {
    <int:Span<"int">> => Type::new(int.0, TypeKind::Int, vec![]),
    <bool:Span<"bool">> => Type::new(bool.0, TypeKind::Bool, vec![]),
    <str:Span<"string">> => Type::new(str.0, TypeKind::String, vec![]),
    <unit:Span<"unit">> => Type::new(unit.0, TypeKind::Unit, vec![]),
    <generic:Span<GenericTypes>> => {
        Type::new(generic.0, generic.1.0.type_kind, generic.1.1)
    }


}

TypeDecl: Type = {
    ":" <ty:Types> => {
        ty
    }
}

LetStmt: (Ident, Option<Type>, Expression) = {
    "let" <t:Ident> <td:TypeDecl?> "=" <e:Expr> => {
        (t, td, e)
    }
}

Let: Statement = {
    <t:Span<LetStmt>> ";" => {
        Statement::Let(
            LetStmt::new(
                t.0,
                t.1.0,
                t.1.1,
                true,
                t.1.2
            )
        )
    }
}


If: Statement = {
    <t:Span<ConditionalStatement<"if">>> => {
        Statement::If(
            If::new(
                t.0,
                t.1.0,
                t.1.1
            )
        )
    },

}

IfElseStmt : (Expression, Statement, Statement) = {
    <ifstmt: ConditionalStatement<"if">> "else" <else_body:Statement> => {
        (ifstmt.0, ifstmt.1, else_body)
    }
}

IfElse: Statement = {
    <t:Span<IfElseStmt>> => {
        Statement::IfElse(
            IfElse::new(
                t.0,
                t.1.0,
                t.1.1,
                t.1.2
            )
        )
    }
}






CallSyntax: (Ident, Vec<Expression>) = {
     <t:Ident> "(" <args:Comma<Expr>> ")" => {
        (t, args)
    }
}



CallExpr: Expression = {
    <t:Span<CallSyntax>> => {
        Expression::Call(
                Call::new(
                    t.1.0.name,
                    t.1.1,
                    t.0
                )
          )

    }
}

Return: Statement = {
    Span<("return" Expr? ";")> => {
        Statement::Return(Return::new(
            <>.1.1,
            <>.0
        ))
    }
}

Expr: Expression = {
    BinOp<Expr, OpTerm, Factor>,
    Factor
};

Factor: Expression = {
    BinOp<Factor, OpFactor, Call>,
    Call
};

Call: Expression = {
    CallExpr,
    Term
}


Term: Expression = {
    Int,
    ExprIdent,
    Bool,
    String
};

Argument: (Ident, Type) = {
    <t:Ident> ":" <ty:Types> => {
        (t, ty)
    }
}

ArgumentStmt: Argument = {
    <t:Span<Argument>> => {
        Argument::new(
            t.1.0.name,
            t.1.1,
            t.0
        )
    }
};

Arguments: Arguments = {
    <args:Span<Comma<ArgumentStmt>>> => {
        Arguments::new(
            args.1,
            args.0
        )
    }
}


FunctionStmt: (Ident, Arguments, Type, Vec<Statement>) = {
   "func" <t:Span<Ident>> <args:Group< "(", Arguments, ")" >> ":" <ty:Types> <body:Block> => {
        (t.1, args.1, ty, body)
    }
}

Function: Statement = {
    <t:Span<FunctionStmt>> => {
        Statement::Function(
            Function::new(
                t.1.0.name,
                t.1.1,
                t.1.2,
                t.1.3,
                t.0
            )
        )
    }
}

PathStmt: Vec<Ident> = {
    <t:Ident> "." <ts:PathStmt> => {
        let mut vec = vec![t];
        vec.extend(ts);
        vec
    },
    <t:Ident> => vec![t]
}

Path: PathImport = {
    <t:Span<PathStmt>> => {
        PathImport::new(
            t.0,
            t.1
        )
    }
}

ImportStmt: PathImport = {
    "import" <t:Path>  => {
        t
    }
}

Import : Statement = {
    <t:Span<ImportStmt>> ";" => {
        Statement::Import(
            ImportStmt::new(
                t.0,
                t.1
            )
        )
    }
}



Ident: Ident = {
    <t:Span<Chars>> => {
        Ident::new(
            t.0,
            t.1.to_string()
        )
    }
}

ExprIdent: Expression = {
    <t:Ident> => Expression::Constant(
                    Constant::Ident(
                        t
                    )
                 )
}

Int: Expression = {
    <t:Span<Num>> => Expression::Constant(
                                Constant::Int(
                                    Int::new(
                                        t.0,
                                        t.1
                                    )
                                )
                            )
}

Bool: Expression = {
    Span<"true"> => Expression::Constant(Constant::Bool(Bool::new(<>.0, true))),
    Span<"false"> => Expression::Constant(Constant::Bool(Bool::new(<>.0, false)))
}

String: Expression = {
    <t:Span<Str>> => Expression::Constant(
                                Constant::StringLiteral(
                                    AstString::new(
                                        t.0,
                                        t.1
                                    )
                                )
                            )
}

Span<T>: (Span, T) = {
    <ll:@L> <t:T> <lr:@R> => (Span::new(ll, lr), t)
}

Comma<T>: Vec<T> = {
    <t:T> "," <ts:Comma<T>> => {
        let mut vec = vec![t];
        vec.extend(ts);
        vec
    },
    <t:T> => vec![t]
}

Statement: Statement = {
    BlockStmt,
    While,
    Let,
    If,
    Function,
    Return,
    Import,
    <e:Expr> ";" =>  Statement::Expression(e)
}

pub File: Vec<Statement> = Statement*;
