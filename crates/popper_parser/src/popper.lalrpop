use std::str::FromStr;
use popper_ast::Expression;
use popper_ast::Statement;
use popper_ast::BinOp;
use popper_ast::BinOpKind;
use popper_ast::Span;
use popper_ast::Constant;
use popper_ast::Int;
use popper_ast::Block;
use popper_ast::While;
use popper_ast::Ident;
use popper_ast::Bool;
use popper_ast::StringLiteral as AstString;
use popper_ast::Type;
use popper_ast::TypeKind;
use popper_ast::LetStmt;
use popper_ast::If;
use popper_ast::IfElse;
use popper_ast::Argument;
use popper_ast::Arguments;
use popper_ast::Function;
use popper_ast::Call;
use popper_ast::Return;
use popper_ast::PathImport;
use popper_ast::ImportStmt;
use popper_ast::External;
use popper_ast::FunctionSign;
use popper_ast::ForStmt;
use popper_ast::StructStmt;
use popper_ast::StructField;
use popper_ast::StructInstance;
use popper_ast::StructFieldInstance;
use popper_ast::StructFieldAccess;
use popper_ast::List;

use popper_common::ast_path_to_path::ast_path_to_path;
use crate::parser::parse;

grammar<'a>;

Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap(),
};

Str: String = {
    <s:r#""(\\.|[^"])*""#> => s.replace("\\\"", "\"").replace("\"", ""), // remove quotes

};


Chars: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string();

OpTerm: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Sub,
}

OpFactor: BinOpKind = {
    "*" => BinOpKind::Mul,
    "/" => BinOpKind::Div,
}

ConditionalStatement<K>: (Expression, Statement) = {
    <keyword:K> <condition:Expr> <statement:Statement>   => (condition, statement)
}

BinOp<Lhs, Op, Rhs>: Expression = {
    <ll:@L> <l:Lhs> <op:Op> <r:Rhs> <lr:@R> => {
        Expression::BinOp(BinOp::new(Span::new(ll, lr), op, l,  r))
    }
}

Group<DelimS, T, DelimE>: (Span, T) = {
    <ll:@L> <ds:DelimS> <t:T> <de:DelimE> <lr:@R> => (Span::new(ll, lr), t)
}

Block: Vec<Statement> = {
    <e:Group<"{", Statement*, "}">> => e.1
}

BlockStmt: Statement = {
    <e:Group<"{", Statement*, "}">> => {
        Statement::Block(
            Block::new(
                e.0,
                e.1
            )
        )
    }

}



While: Statement = {
    <t:Span<ConditionalStatement<"while">>> => {
        Statement::While(
            While::new(
                t.0,
                t.1.0,
                t.1.1
            )
        )
    }
}

GenericTypes: (Type, Vec<Type>) = {
    <t:Types> "<" <ts:Comma<Types>> ">" => {
        (t, ts)
    }
}

StringType: TypeKind = {
    "string"  <t:Num?> => {
        if let Some(t) = t {
            TypeKind::String(t.try_into().unwrap())
        } else {
            TypeKind::String(0)
        }
    }
}

StructType: TypeKind = {
    "struct" "{" <fields:Comma<StructField>> "}" => {
        TypeKind::Struct(fields.iter().map(|f| (f.name.clone(), f.ty.clone())).collect())
    }
}

ListType: TypeKind = {
    "[" <t:Types> <n:(":" Num)?> "]" => {
        if let Some(n) = n {
            TypeKind::List(Box::new(t), n.1.try_into().unwrap())
        } else {
            TypeKind::List(Box::new(t), 0)
        }
    }
}

Types: Type = {
    <int:Span<"int">> => Type::new(int.0, TypeKind::Int, vec![]),
    <bool:Span<"bool">> => Type::new(bool.0, TypeKind::Bool, vec![]),
    <str:Span<StringType>> => Type::new(str.0, str.1, vec![]),
    <unit:Span<"unit">> => Type::new(unit.0, TypeKind::Unit, vec![]),
    <struct_:Span<StructType>> => Type::new(struct_.0, struct_.1, vec![]),
    <generic:Span<GenericTypes>> => {
        Type::new(generic.0, generic.1.0.type_kind, generic.1.1)
    },
    <list:Span<ListType>> => Type::new(list.0, list.1, vec![]),


}

TypeDecl: Type = {
    ":" <ty:Types> => {
        ty
    }
}

LetStmt: (Ident, Option<Type>, Expression) = {
    "let" <t:Ident> <td:TypeDecl?> "=" <e:Expr> => {
        (t, td, e)
    }
}

Let: Statement = {
    <t:Span<LetStmt>> ";" => {
        Statement::Let(
            LetStmt::new(
                t.0,
                t.1.0,
                t.1.1,
                true,
                t.1.2
            )
        )
    }
}


If: Statement = {
    <t:Span<ConditionalStatement<"if">>> => {
        Statement::If(
            If::new(
                t.0,
                t.1.0,
                t.1.1
            )
        )
    },

}

IfElseStmt : (Expression, Statement, Statement) = {
    <ifstmt: ConditionalStatement<"if">> "else" <else_body:Statement> => {
        (ifstmt.0, ifstmt.1, else_body)
    }
}

IfElse: Statement = {
    <t:Span<IfElseStmt>> => {
        Statement::IfElse(
            IfElse::new(
                t.0,
                t.1.0,
                t.1.1,
                t.1.2
            )
        )
    }
}


CallSyntax: (Ident, Vec<Expression>) = {
     <t:Ident> "(" <args:Comma<Expr>?> ")" => {
        if let Some(args) = args {
            (t, args)
        } else {
            (t, vec![])
        }
    }
}

Return: Statement = {
    Span<("return" Expr? ";")> => {
        Statement::Return(Return::new(
            <>.1.1,
            <>.0
        ))
    }
}



CallExpr: Expression = {
    <t:Span<CallSyntax>> => {
        Expression::Call(
                Call::new(
                    t.1.0.name,
                    t.1.1,
                    t.0
                )
          )

    }
}

StructInstanceSyntax: (Ident, Vec<StructFieldInstance>) = {
    "init" <t:Ident> "{" <fields:Comma<StructFieldInstance>> "}" => {
        (t, fields)
    }
}

StructFieldInstanceSyntax: (Ident, Expression) = {
    <t:Ident> "=" <expr:Expr> => {
        (t, expr)
    }
}

StructFieldInstance: StructFieldInstance = {
    <t:Span<StructFieldInstanceSyntax>> => {
        StructFieldInstance::new(
            t.1.0.name,
            t.1.1,
            t.0
        )
    }
}

StructInstanceExpr: Expression = {
    <t:Span<StructInstanceSyntax>> => {
        Expression::StructInstance(
            StructInstance::new(
                t.1.0.name,
                t.1.1,
                t.0
            )
        )
    }
}

FieldAccessSyn: (Ident, Ident) = {
    <e:Ident> "." <t:Ident> => {
        (e, t)
    }
}

FieldAccessExpr: Expression = {
    <t:Span<FieldAccessSyn>> => {
        Expression::StructFieldAccess(
            StructFieldAccess::new(
                t.1.0.name,
                t.1.1.name,
                t.0
            )
        )
    }
}



Expr: Expression = {
    BinOp<Expr, OpTerm, Factor>,
    Factor
};

Factor: Expression = {
    BinOp<Factor, OpFactor, Call>,
    Call
};


Call: Expression = {
    CallExpr,
    FieldAccess
}

FieldAccess: Expression = {
    FieldAccessExpr,
    StructInstance
}

StructInstance: Expression = {
    StructInstanceExpr,
    ListExpr
}

ListExpr: Expression = {
    List,
    Term
}


Term: Expression = {
    Int,
    ExprIdent,
    Bool,
    String
};

Argument: (Ident, Type) = {
    <t:Ident> ":" <ty:Types> => {
        (t, ty)
    }
}

ArgumentStmt: Argument = {
    <t:Span<Argument>> => {
        Argument::new(
            t.1.0.name,
            t.1.1,
            t.0
        )
    }
};

Arguments: Arguments = {
    <args:Span<Comma<ArgumentStmt>?>> => {
        Arguments::new(
            if let Some(args) = args.1 {
                args
            } else {
                vec![]
            },
            args.0
        )
    }
}


FunctionStmt: (Ident, Arguments, Type, Vec<Statement>) = {
   "func" <t:Span<Ident>> <args:Group< "(", Arguments, ")" >> ":" <ty:Types> <body:Block> => {
        (t.1, args.1, ty, body)
    }
}

Function: Statement = {
    <t:Span<FunctionStmt>> => {
        Statement::Function(
            Function::new(
                t.1.0.name,
                t.1.1,
                t.1.2,
                t.1.3,
                t.0
            )
        )
    }
}

FunctionSignatureSyntax: (Ident, Arguments, Type) = {
    "func" <t:Span<Ident>> <args:Group< "(", Arguments, ")" >> ":" <ty:Types> => {
        (t.1, args.1, ty)
    }
}


FunctionSignature: FunctionSign = {
    <t:Span<FunctionSignatureSyntax>> => {
        FunctionSign::new(
            t.0,
            t.1.0.name,
            t.1.1,
            t.1.2
        )
    }
}

ExternalStmt : (String, Vec<FunctionSign>) = {
    "external" <s:Str> "{" <fs:Span<Comma<FunctionSignature>>>  "}" => {
        (s, fs.1)
    }
}

External: Statement = {
    <t:Span<ExternalStmt>> ";" => {
        Statement::External(
            External::new(
                t.0,
                t.1.0,
                t.1.1
                )
        )
    }
}

ForStmt: (Ident, Expression, (Span, Vec<Statement>)) = {
    "for" <t:Ident> "in" <expr:Expr> <body:Span<Block>> => {
        (t, expr, body)
    }
}

For: Statement = {
    <t:Span<ForStmt>> => {
        Statement::For(
            ForStmt::new(
                t.1.0,
                t.1.1,
                Block::new(
                    t.1.2.0,
                    t.1.2.1
                ),
                t.0
            )
        )
    }
}


PathStmt: Vec<Ident> = {
    <t:Ident> "." <ts:PathStmt> => {
        let mut vec = vec![t];
        vec.extend(ts);
        vec
    },
    <t:Ident> => vec![t]
}

Path: PathImport = {
    <t:Span<PathStmt>> => {
        PathImport::new(
            t.0,
            t.1
        )
    }
}

ImportStmt: (PathImport, Vec<Statement>) = {
    "import" <t:Path>  => {
        let path = ast_path_to_path(t.clone());
        let content = std::fs::read_to_string(path.clone()).unwrap();
        let opt = parse(&content, path.to_str().unwrap());
        (t, opt.unwrap())
    }
}

Import : Statement = {
    <t:Span<ImportStmt>> ";" => {
        Statement::Import(
            ImportStmt::new(
                t.0,
                t.1.0,
                t.1.1
            )
        )
    }
}

StructCreate: (Ident, Vec<StructField>) = {
    "struct" <t:Ident> "{" <fields:Comma<StructField>> "}" => {
        (t, fields)
    }
}

StructStmt: Statement = {
    <t:Span<StructCreate>> => {
        Statement::Struct(
            StructStmt::new(
                t.1.0.name,
                t.1.1,
                t.0
            )
        )
    }
}

StructFieldSyntax: (Ident, Type) = {
    <t:Ident> "=" <ty:Types> => {
        (t, ty)
    }
}

StructField: StructField = {
    <t:Span<StructFieldSyntax>> => {
        StructField::new(
            t.1.0.name,
            t.1.1,
            t.0
        )
    }
}




Ident: Ident = {
    <t:Span<Chars>> => {
        Ident::new(
            t.0,
            t.1.to_string()
        )
    }
}

ExprIdent: Expression = {
    <t:Ident> => Expression::Constant(
                    Constant::Ident(
                        t
                    )
                 )
}

Int: Expression = {
    <t:Span<Num>> => Expression::Constant(
                                Constant::Int(
                                    Int::new(
                                        t.0,
                                        t.1
                                    )
                                )
                            )
}

Bool: Expression = {
    Span<"true"> => Expression::Constant(Constant::Bool(Bool::new(<>.0, true))),
    Span<"false"> => Expression::Constant(Constant::Bool(Bool::new(<>.0, false)))
}

String: Expression = {
    <t:Span<Str>> => Expression::Constant(
                                Constant::StringLiteral(
                                    AstString::new(
                                        t.0,
                                        t.1
                                    )
                                )
                            )
}

List: Expression = {
    Group<"[", Comma<Expr>?, "]"> => {
        if let Some(exprs) = <>.1 {
            Expression::Constant(
                Constant::List(
                    List::new(
                        <>.0,
                        exprs
                    )
                )
            )
        } else {
            Expression::Constant(
                Constant::List(
                    List::new(
                        <>.0,
                        vec![]
                    )
                )
            )
        }
    }
}

Span<T>: (Span, T) = {
    <ll:@L> <t:T> <lr:@R> => (Span::new(ll, lr), t)
}

Comma<T>: Vec<T> = {
    <t:T> "," <ts:Comma<T>> => {
        let mut vec = vec![t];
        vec.extend(ts);
        vec
    },
    <t:T> => vec![t]
}

// ;



Statement: Statement = {
    BlockStmt,
    While,
    Let,
    If,
    Function,
    Return,
    Import,
    External,
    For,
    StructStmt,
    <e:Expr> ";" =>  Statement::Expression(e)
}

pub File: Vec<Statement> = Statement*;
